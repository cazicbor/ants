from random import random, randint, sample
from collections import namedtuple

# Calculate the capital invested by an individual
def investedCapital(individual):    
    return sum(map(lambda x,y: x*y.price, individual, investments))

# Calulate the performance got by an individual
def individualPerformance(individual):
    return sum(map(lambda x,y: x*y.price*y.performance, individual, investments))

# If an individual spends more capital than is available, investments are randomly eliminated until capital is adjusted
def adjustCapital(individual): 
    adjusted=individual[:] 
    while investedCapital(adjusted)>capital: 
        pos = randint(0,len(adjusted)-1) 
        if adjusted[pos]>0: 
            adjusted[pos]-=1 
    return adjusted

# Creates a random individual, in this case a selection of investments that do not exceed the available capital
def createIndividual(investments,capital): 
    individual =[0]*len(investments) 
    while investedCapital(individual)<capital: 
        choice=randint(0,len(investments)-1) 
        individual[choice]+=1 
    return adjustCapital(individual)

# Creates a new individual by crossing two others (whose positions are indicated in the second parameter)
def cross(population, positions): 
    L=len(population[0])

    # Takes the genes from the first parent and then randomly takes a segment between 1 and L genes from the second parent
    
    child=population[positions[0]][:] 
    beginning=randint(0,L-1) 
    ending=randint(beginning+1,L) 
    child[beginning:ending]=population[positions[1]][beginning:ending] 
    
    return adjustCapital(child)

# Applies mutations to an individual at a given rate; guarantees that it meets the capital and investment restrictions
def mutate(individual, mutationTax): 
    mutated =[] 
    for i in range(len(individual)): 
        if random()>mutationTax: 
            mutated.append(individual[i]) 
        else: 
            mutated.append(randint(0,investments[i].quantity)) 
    
    return adjustCapital(mutated)

# Makes the system evolve over a number of generations
def evolve(population, generations): 
    
    # Dorts the initial population by performance produced
    population.sort(key=lambda x:individualPerformance(x)) 
    
    # Useful values
    N=len(population) 
    mutationTax=0.01 
    
    # Generates a list of the type [0, 1, 1, 2, 2, 2, 3, 3, 3, 3, ...] to represent the probabilities of reproducing for each individual (the first 1 possibility, the second 2, etc.) 
    reproduction=[x for x in range(N) for y in range(x+1)] 
    for i in range(generations): 
        # N-1 new individuals are generated by crossing existing ones (without repeating the parents)
        parents=sample(reproduction,2) 
        while parents[0]==parents[1]:
            parents=sample(reproduction,2) 
            children=[cross(population,parents) for x in range(N-1)] 
            
            # Mutations are applied with a certain probability
            children=[mutate(x, mutationTax) for x in children] 
            
            # The best individual from the previous population is added (elitism)
            children.append(population[-1]) 
            population = children 
            
            # Individuals are ordered by performance
            population.sort(key=lambda x:individualPerformance(x)) 
            
            # Returns the best individual found
    return population[-1]


# Declare a tuple with names to represent each inversion
Investment=namedtuple('Investment', 'price quantity performance') 

numberOfInvestments=100 
maxPrice= 1000 
maxQuantity=10 
maxPerformance=0.2

# Generates a list of investment tuples
investments=[Investment(random()*maxPrice, randint(1, maxQuantity), random()*maxPerformance) for i in range(numberOfInvestments)] 
print(investments)

capital = 50000 
individuals = 20 
generations = 1000 
population=[createIndividual(investments, capital) for i in range(individuals)]

# To simplify the program, investments and capital are accessed globally (they are only read, not modified) 
best=evolve(population, generations) 
print(best, investedCapital(best), individualPerformance(best))